# Fuse Project Report
## Author: Ryan Moffitt (rmoff938)
Time spent: 53 hours

### Thoughts and reflections
This project was a ton of fun to work on, perhaps the most fun just in exploritory work mainly because there were visible results fairly early on. I worked a lot on the framework for handling parsing the img file and getting the appropriate structures into memory, and then putting the functionallity in place to make sure everything got updated when we attempted to do a read/write. A little bit more on that later. I thought this project was a great way to get your hands into a fairly easy to learn file system and understand what exactly goes into making one. There were a couple hitches, such as how to detect null directory entries, or what lookupCount was, but I'll discuss that in a future section. All in all, very happy with what we were able to get done and very happy with how much I learned from the project.

### Framework
Ok so to start off we were just trying to figure out what the file system was and what each of the fields meant. We probably could've spent a bit more time just hypothesising how all the data was going to work together, but we chose to just go for it and start parsing the file to get it to a point where we could point out the directory tree. I think I spent my first 13 hours putting together a program capable of getting the data into a proper format and figuring out which classes we would need. We had one hitch where we were getting absolutely absurd numbers for the sector pointers to the I-List and following, but that was just because one of the fields for the total file size was missing in the docs. After we got that all put together, we had sort of a mess. We were thinking about how to write to the file and realized our way of parsing the file made it so that we couldn't reuse any of our functions to write back to the file. That resulted in us starting over on the second program which was geared a lot more towards being able to write back. As stated in the technical document, we chose a simple over efficient mindset, so a lot of our functions could be more elegant just by the use of more complex data structures, but it works for our purposes. I think I could've written the read and writes slightly better by not abstracting as much as I did. The way I currently have it makes it hard to not go through the proper functions to do a write, which means in order to add a new functionallity you also have to write a new call. That being said, I'm quite happy with how that framework turned out.

### FUSE
So once we finished the framework, the hard part was actually mostly over. There were a couple more hitches we hit in porting it over to use in fuse, but that was mostly configuration and certain checks for fields. One thing that really helped me for figuring out if my configurations were working for FUSE was looking at both the request handler documentation: https://www.rath.org/llfuse-docs/operations.html, to see exactly which functions we needed to implement, and looking at https://gist.github.com/akiross/3d7952b186d523c61cbc, mainly because this tutorial told you what methods need to be implemented for which action (ls, mkdir, echo, etc...). There were a couple of particularly confusing calls, such as lookup, which I'm still not entirely sure that I understand. We didn't implement any of the x varient calls because I don't think our filesystem holds the proper metadata to make the best use of those. One of the problems we hit was the problem of null directory entires. Imagine that for a directory you have three entries in it, you then add a fourth one but remove the third. Your size for the directory file stays the same, but you only have 3 valid entries while there is room for four. Seeing as 0 is a valid inode number, you can't check the indoe field for validity, so we ended up just checking to see if the first byte of the name is 0, in which case the entry would be invalid. The second issue was deleting files and what exactly lookupCount is. This is how it was explained to me and what I believe it to be. lookupCount is the number of references llfuse keeps to a file for its own caching use and the such. Similar to reference count and link count, you can't delete the file until the lookupCount is 0 as well as the other fields. The llfuse docs tell exactly which functions should increment lookupCount, and forget is the only function that should decrement lookupCount. This gets us into a position where there are only two places where files should actually ever be "deleted". To delete a file we set its mode bit to 0, to indicate to the alloc inode process that it can be reclaimed for another process. We only do that in unlink and forget. unlink is the only function that decrements linkcount and forget is the only place that decrements lookupCount, so when both of those fields become 0 in either of those functions, we can set the mode bit to zero. That was probably the most confusing section of this entire project, and other than that it was pretty smooth sailing.

### Teamate
Mr. Taylor was a great teamate. I fear I may have taken too much of the work from him, but he was always quick on the uptake and eager to do and understand stuff. Understanding his schedule he took on just as much as he humanly could, and I was very happy with our results from working together.
